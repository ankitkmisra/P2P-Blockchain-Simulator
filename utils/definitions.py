import copy
import numpy as np 
import networkx as nx
from random import sample
from numpy.random import default_rng

from utils.utils import verifyBlock, computeLatency, pushq

rng = default_rng(42)

class Event:
    """
    Event class: Stores all types of Events
    
    EVENT_TYPES: "TxnGen", "TxnRecv", "BlockRecv", "BlockMined"
    """

    def __init__(self, time, event_type, txn=None, block=None, sender=-1, receiver=-1):
        self.time = time
        self.event_type = event_type
        self.txn = txn
        self.block = block
        self.sender = sender
        self.receiver = receiver
    

class Block:
    time=0
    def __init__(self, bid, pbid, txnIncluded, miner):
        self.bid = bid # block id
        self.pbid = pbid #parent block id
        self.size = 1 + len(txnIncluded) #size of block
        if pbid != 0: #to check if it is not genesis block
            # self.txnIncluded = copy.deepcopy(txnIncluded)
            self.txnIncluded = txnIncluded
        else:
            self.txnIncluded = set()
        self.miner = miner

        # txnPool stores all the txn mined till now 
        # length shows the length of chain from genesis block till current block 
        if pbid != 0:
            # self.txnPool = copy.deepcopy(pbid.txnPool)
            self.txnPool = pbid.txnPool
            self.length = pbid.length+1
        else:
            self.txnPool = set()
            self.length = 1
        
        for a in txnIncluded:
            self.txnPool.add(a)

        if pbid != 0:
            self.balance = copy.deepcopy(pbid.balance)
        else:
            self.balance = []
        for a in txnIncluded: #updating balance of all the user 
            if a.sender != -1:
                self.balance[a.sender.nid] -= a.value
            self.balance[a.receiver.nid] += a.value
            
    def __str__ (self):
        return f"Id:{self.bid},Parent:{self.pbid.bid}, Miner:{self.miner}, Txns:{len(self.txnIncluded)}, Time:{self.time}, Size:{self.size}"
    

class Node:
    blockChain = {} # blockchain of the node
    peers = set() # neighbours of the node
    txnReceived = set() # txn received till now 
    blockReceived = set() # blocks received till now 
    g = nx.DiGraph() # graph


    def __init__(self, nid, speed, cpu, genesis, miningTime, blkgen, txngen):
        self.nid = nid # unique id of the node 
        self.speed = speed # 1=fast, 0=slow
        self.cpu = cpu
        self.lbid = genesis.bid
        # self.blockChain[genesis.bid] = copy.deepcopy(genesis)
        self.blockChain[genesis.bid] = genesis
        self.blkid_generator = blkgen
        self.txnid_generator = txngen
        self.miningTime = miningTime # represent the mining power of node. It is the mean mining time of node

    def __str__ (self):
        return f"(Id:{self.nid})"

    #to establish connection between two node
    def addPeer(self,node):
        self.peers.add(node) 

    # this function is called if a new transaction is generated by the node 
    def txnSend(self, event):
        if self.blockChain[self.lbid].balance[self.nid] <= 0:
            return 
        event.txn.value = np.random.randint(1, self.blockChain[self.lbid].balance[self.nid]+1)
        self.txnReceived.add(event.txn)
        for a in self.peers:
            t = event.time + computeLatency(self, a, 1)
            pushq(Event(t, event_type="TxnRecv", sender=self, receiver=a, txn=event.txn))
            

    # this function is called if the node recevies information about a transaction from its neighbours
    def txnRecv(self,event):
        if event.txn in self.txnReceived:
            return 
        self.txnReceived.add(event.txn)
        for a in self.peers:
            t = event.time + computeLatency(self, a, 1)
            pushq(Event(t, event_type="TxnRecv", sender=self.nid, receiver=a, txn=event.txn))
    

    # this function is called if node wants to mine a new block with given parent block
    def mineNewBlock(self, block, lat):
        remaingTxn = self.txnReceived.difference(block.txnPool)
        toBeDeleted = set()

        for a in remaingTxn:
            if a.value > block.balance[a.sender.nid]:
                toBeDeleted.add(a)
        
        remaingTxn = remaingTxn.difference(toBeDeleted)

        numTxn = len(remaingTxn)
        
        if len(remaingTxn) > 1:
            numTxn = min(np.random.randint(1, len(remaingTxn)), 1022) # 1 for coinbase txn, 1 for itself

        txnToInclude = set(sample(remaingTxn, numTxn))
        txnId = next(self.txnid_generator)
        coinBaseTxn = Transaction(tid=txnId, sender=-1,
                                  receiver=self, value=50)
        txnToInclude.add(coinBaseTxn)

        newBlockId = next(self.blkid_generator)
        newBlock = Block(bid=newBlockId, pbid=block,
                         txnIncluded=txnToInclude, miner=self)

        lat = lat + rng.exponential(self.miningTime)
        pushq(Event(lat, event_type="BlockMined", block=newBlock))


    #this function is called, if block receives a node from its peers
    #block is verified and if the block is without any errors then its is added to blockchain 
    # and then transmitted to neighbours 
    # If addition of that block creates a primary chain then mining is started over that block
    def verifyAndAddReceivedBlock(self, event):
        if event.block.bid in self.blockReceived:
            return 
        self.blockReceived.add(event.block.bid)

        if not verifyBlock(event.block):
            return

        # temp = copy.deepcopy(event.block)
        temp = event.block
        temp.time = event.time
        self.blockChain[temp.bid] = temp
        self.g.add_edge(temp.bid, temp.pbid.bid)
        if temp.length > self.blockChain[self.lbid].length:
            self.lbid = temp.bid
            self.mineNewBlock(block=temp, lat=event.time)

        for a in self.peers:
            lat = event.time + computeLatency(i=self, j=a, m=temp.size)
            pushq(Event(lat, event_type="BlockRecv", sender=self, receiver=a, block=temp))
    
    # thsi function is called once the mining of a block is completed, 
    # If after mining the addition of block creates a primary chain then
    # the block is shared with neighbours and mining is continued otherwise 
    # node waits a block whose addition will, create primary chain
    def receiveSelfMinedBlock(self, event):
        # temp = copy.deepcopy(event.block)
        temp = event.block
        temp.time = event.time

        self.blockChain[temp.bid] = temp
        self.g.add_edge(temp.bid, temp.pbid.bid)
        
        self.blockReceived.add(temp.bid)

        if temp.length > self.blockChain[self.lbid].length:
            self.lbid = temp.bid
            for a in self.peers:
                lat = event.time + computeLatency(i=self, j=a, m=temp.size)
                pushq(Event(lat, event_type="BlockRecv", sender=self, receiver=a, block=temp))
                self.mineNewBlock(block=temp, lat=event.time)


class Transaction:
    def __init__(self, tid, sender, receiver, value):
        self.sender=sender
        self.receiver=receiver
        self.value=value
        self.tid=tid #transaction id
    
    def __str__(self):
        return f"Id: {self.tid}, Sender:{self.sender.nid}, Receiver: {self.receiver.nid} Value: {self.value}"
